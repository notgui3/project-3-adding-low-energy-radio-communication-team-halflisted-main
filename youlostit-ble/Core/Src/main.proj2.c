///**
// ******************************************************************************
// * @file           : main.c
// * @author         : Auto-generated by STM32CubeIDE
// * @brief          : Main program body
// ******************************************************************************
// * @attention
// *
// * Copyright (c) 2023 STMicroelectronics.
// * All rights reserved.
// *
// * This software is licensed under terms that can be found in the LICENSE file
// * in the root directory of this software component.
// * If no LICENSE file comes with this software, it is provided AS-IS.
// *
// ******************************************************************************
// */
//
//#include <stdint.h>
//
///* Include memory map of our MCU */
//#include <stm32l475xx.h>
//
///* Include LED driver */
//#include "leds.h"
//
////Include Timer driver
//#include "timer.h"
//
//#if !defined(__SOFT_FP__) && defined(__ARM_FP)
//  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
//#endif
//
//// Important for TIM2_IRQHandler. See comment in function definition.
//#define bitmask_uint8 0xC0    // 0b1100_0000
//#define bitmask_uint16 0xC000 // 0b1100_0000_0000_0000
//
////Timer for blinking, scaled by TIM2 interrupt --> Currently at 50ms for ARR register --> 1200 * 50ms = 1 minute
//#define timeToBlink 1200
////Sensitiviy for the +- margin of error for checking if the board moved
//#define sensitivity 1200
//
////current X, Y, Z Acceleration values
//static int16_t currX = 0;
//static int16_t currY = 0;
//static int16_t currZ = 0;
//
////X, Y, Z Acceleration values for the previous call
//static int16_t prevX = 0;
//static int16_t prevY = 0;
//static int16_t prevZ = 0;
//
//// Preamble hex value for setting the LEDs
//static volatile uint8_t preamble = 0x99; // 0b10011001
//// Yoav's Student ID for setting the LEDs
//static volatile uint16_t student_id = 7031; // Yoav's student ID 0b0001_1011_0111_0111
//// Time passed for setting the LEDs, should be equal to the lostCount/timeToBlink --> tells how many minutes have passed
//static volatile uint8_t min_lost = 0;
//
//// How many 50ms cycles has passed
//static volatile int lostCount = 0;
//// How many times the current and previous acceleration values haven't mathed
//// Has a +- margin of error according to the sensitivity
//static int changeCount = 0;
//
//// Redefine the libc _write() function so you can use printf in your code
//int _write(int file, char *ptr, int len) {
//	int i = 0;
//	for (i = 0; i < len; i++) {
//		ITM_SendChar(*ptr++);
//	}
//	return len;
//}
//
//int main(void)
//{
//
//	// intialize LEDs
//	leds_init();
//
//	// Initialize Timer
//	timer_init(TIM2);
//
//	// Initialize I2C2 in master mode to connect with the accelerometer
//	i2c_init();
//
//	// Initialize the accelerometer
//	lsm6dsl_init();
//
//	//Set the Timer2 Interrupt to a period of 50 ms
//	timer_set_ms(TIM2, 50);
//
//
//
//	/* Loop forever */
//	for(;;){
//
//		//Read the current accelerometer X, Y, Z Values
//		lsm6dsl_read_xyz(&currX, &currY, &currZ);
//		// 16393 = 1G
//
//		//Print out current X, Y, Z acceleration values
//		printf("%d, %d, %d \n", currX, currY, currZ);
//
//
//		// If the current and previous values X, Y, Z acceleration values are outside the margin of error, increment the changeCount
//		// Otherwise set the change count to 0
//		if((currX >= prevX - sensitivity)& (currX <= prevX + sensitivity)&
//				(currY >= prevY - sensitivity)&(currY <= prevY + sensitivity)&
//				(currZ >= prevZ - sensitivity)& (currZ <= prevZ + sensitivity))
//		{
//			changeCount = 0;
//		}else{
//			changeCount++;
//		}
//
//		// If the changeCount is large than 15, we considered it moved, set the lostCount and changeCount to 0
//		if(changeCount > 8){
//			lostCount = 0;
//			changeCount = 0;
//		}
//
//		// Set previous X, Y, Z acceleration values to the current values for the next loop
//		prevX = currX;
//		prevY = currY;
//		prevZ = currZ;
//
//		// Print the values of lostCount and changeCount
//		printf("lostCount: %d          changeCount: %d          ", lostCount, changeCount);
//
//		// If the lostCount is lower than the timeToBlink (1 min), have the LEDs off
//		if(lostCount < timeToBlink){
//			leds_set(0);
//			//timer_set_ms(TIM2, 50);
//			//timer_reset(TIM2);
//		}
//	}
//}
//
//void TIM2_IRQHandler(){
//	/* The `leds_set` function maps the second bit to LED 2 and the first bit to
//	 * LED 1. The variable `preamble` encodes the writeup's preamble according
//	 * to this format. It was converted by hand.
//	 *
//	 * The bitmasks `bitmask_uint16` and `bitmask_uint8` are used to isolate the
//	 * top two bits in `preamble` and `student_id` respectively. These bits are
//	 * used as input for `leds_set`, then shifted out of the sequence.
//	 *
//	 * We use static variables because they persist between iterations and are
//	 * quite handy here.
//	 */
//
//	// If the lostCount is larger or equal than the timeToBlink (been a minute or over), then start blinking the lost LED signals
//	if(lostCount >= timeToBlink){
//		// Process preamble two bits at a time, until there are no more bits.
//		if (preamble){
//			// map top two bits to LEDs via function
//			uint16_t top_two_bits = (preamble & bitmask_uint8) >> (8-2);
//			leds_set(top_two_bits);
//			preamble <<= 2;         // shift out top two bits
//		}
//
//		// Process student_id once there are no more preamble bits. Same process as
//		// preamble, but for 16 bits.
//		else if (student_id){
//			uint16_t top_two_bits = (student_id & bitmask_uint16) >> (16-2);
//			leds_set(top_two_bits);
//			student_id <<= 2;
//		}
//		// Process the min_lost two bits at a time and set the LEDs to the value to indicate amount of minutes lost
//		else if(min_lost){
//			// map top two bits to LEDs via function
//			uint16_t top_two_bits = (min_lost & bitmask_uint8) >> (8-2);
//			leds_set(top_two_bits);
//			min_lost <<= 2;	// shift out top two bits we used
//		}
//		// Set preamble and student_id variables to default values and update min_lost to check amount of minustes lost when loop is done.
//		else {
//			preamble = 0x99;
//			student_id = 7031; // yoav student id
//			min_lost = lostCount/timeToBlink;
//		}
//	}
//
//	//Increment the lostCounter every time Timer 2 interrupt activates
//	lostCount++;
//
//	// Reset update flag.
//	TIM2->SR &= ~(TIM_SR_UIF);
//
//}
